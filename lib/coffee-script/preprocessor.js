// Generated by CoffeeScript 1.7.1
(function() {
  var cPreProcessor, dirOpen, fs, gn, gw, makros, optionParse, path, startWatcher, style, styles, subscribeChange, systemPaths, timers, unsubscribeChange, wait, watchers, _fn, _i, _len,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  makros = null;

  watchers = {};

  systemPaths = [];

  dirOpen = null;

  gw = null;

  gn = '';

  timers = {};

  if ((typeof process !== "undefined" && process !== null) && !(/^win/.test(process.platform))) {
    styles = {
      'bold': ['\x1B[1m', '\x1B[22m'],
      'italic': ['\x1B[3m', '\x1B[23m'],
      'underline': ['\x1B[4m', '\x1B[24m'],
      'inverse': ['\x1B[7m', '\x1B[27m'],
      'strikethrough': ['\x1B[9m', '\x1B[29m'],
      'white': ['\x1B[37m', '\x1B[39m'],
      'grey': ['\x1B[90m', '\x1B[39m'],
      'black': ['\x1B[30m', '\x1B[39m'],
      'blue': ['\x1B[34m', '\x1B[39m'],
      'cyan': ['\x1B[36m', '\x1B[39m'],
      'green': ['\x1B[32m', '\x1B[39m'],
      'magenta': ['\x1B[35m', '\x1B[39m'],
      'red': ['\x1B[31m', '\x1B[39m'],
      'yellow': ['\x1B[33m', '\x1B[39m'],
      'whiteBG': ['\x1B[47m', '\x1B[49m'],
      'greyBG': ['\x1B[49;5;8m', '\x1B[49m'],
      'blackBG': ['\x1B[40m', '\x1B[49m'],
      'blueBG': ['\x1B[44m', '\x1B[49m'],
      'cyanBG': ['\x1B[46m', '\x1B[49m'],
      'greenBG': ['\x1B[42m', '\x1B[49m'],
      'magentaBG': ['\x1B[45m', '\x1B[49m'],
      'redBG': ['\x1B[41m', '\x1B[49m'],
      'yellowBG': ['\x1B[43m', '\x1B[49m']
    };
    _fn = function(style) {
      return String.prototype[style] = function(val) {
        if (val == null) {
          val = '';
        }
        return styles[style][0] + this + val + styles[style][1];
      };
    };
    for (style in styles) {
      if (!__hasProp.call(styles, style)) continue;
      _fn(style);
    }
  } else {
    styles = ['bold', 'italic', 'underline', 'inverse', 'strikethrough', 'white', 'grey', 'black', 'blue', 'cyan', 'green', 'magenta', 'red', 'yellow', 'whiteBG', 'greyBG', 'blackBG', 'blueBG', 'cyanBG', 'greenBG', 'magentaBG', 'redBG', 'yellowBG'];
    for (_i = 0, _len = styles.length; _i < _len; _i++) {
      style = styles[_i];
      String.prototype[style] = function(val) {
        if (val == null) {
          val = '';
        }
        return this + val;
      };
    }
  }

  wait = function(time, func) {
    return setTimeout(func, time);
  };

  startWatcher = function(path) {
    fs.exists(path, function(e) {
      if (!e) {
        console.log(("" + ('File not exists:'.red()) + " " + (path.white()) + "\n").bold());
        return;
      }
      fs.watch(path, function(action, pathChanged) {
        if (timers[pathChanged] != null) {
          clearTimeout(timers[pathChanged]);
        }
        timers[pathChanged] = wait(25, function() {
          var i, w, _ref;
          _ref = watchers[path];
          for (i in _ref) {
            if (!__hasProp.call(_ref, i)) continue;
            w = _ref[i];
            if (w != null) {
              if (typeof w.emit === "function") {
                w.emit('change', true);
              }
            }
          }
        });
      });
    });
  };

  subscribeChange = function(pathChangedFile, pathCoreFile, coreWatchers) {
    if (watchers[pathChangedFile] == null) {
      watchers[pathChangedFile] = {};
    }
    watchers[pathChangedFile][pathCoreFile] = coreWatchers;
    return startWatcher(pathChangedFile);
  };

  unsubscribeChange = function(pathCoreFile) {
    var collect, i;
    for (i in watchers) {
      if (!__hasProp.call(watchers, i)) continue;
      collect = watchers[i];
      if (collect.hasOwnProperty(pathCoreFile)) {
        delete collect[pathCoreFile];
      }
    }
  };

  cPreProcessor = function(source, filename, indent) {
    var ad, an, ba, buf, c, c2, cl, d, def, defFull, define, di, directives, dm, ecran, error, f, i, i2, ifactive, ifpassed, iftrue, include, isw, l, line, n, nfound, os, out, q, replace, s, sd, sl, token, undef, warn, word, wr;
    if (indent == null) {
      indent = "";
    }
    directives = ['include', 'define', 'undef', 'if', 'elif', 'else', 'endif', 'ifdef', 'ifndef'];
    word = '';
    an = /^\w$/;
    sl = /^\s*$/;
    def = /^(\w+)(?:\s+(.*))?$/;
    defFull = /^(\w+)(\(\s*(\.\.\.|(\w+\s*(,\s*\w+\s*)*(,\s*\.\.\.)?))\s*\))?(\s+.*)?$/;
    n = /\n/g;
    dm = null;
    out = '';
    buf = '';
    f = 0;
    q = 0;
    source += '\n';
    s = false;
    cl = false;
    d = false;
    sd = false;
    ba = false;
    di = false;
    iftrue = false;
    ifactive = 0;
    ifpassed = false;
    ad = -1;
    i = -1;
    i2 = -1;
    line = 1;
    nfound = 0;
    ecran = false;
    replace = true;
    l = source.length;
    define = function(name, value) {
      if (value == null) {
        makros[name] = '';
        return;
      }
      makros[name] = value;
    };
    undef = function(name) {
      if (name !== '') {
        if (makros.hasOwnProperty(name)) {
          return makros[name] = null;
        } else {
          return warn("Index " + (name.blue()) + " haven't in makros. Undef fail");
        }
      } else {
        return warn("Undef is empty");
      }
    };
    token = function(name, stack) {
      var val, w, words, _j, _len1;
      if (stack == null) {
        stack = [];
      }
      if ((!replace) || cl) {
        return name;
      }
      if (makros.hasOwnProperty(name) && (makros[name] != null)) {
        if (stack.length > 32) {
          warn("Tokenise stak max size!!!");
          stack.pop();
          return name;
        }
        if (stack.length > 16) {
          warn("Tokenise stak warn size: " + stack.length);
        }
        if (__indexOf.call(stack, name) >= 0) {
          stack.pop();
          return name;
        }
        stack.push(name);
        val = makros[name];
        words = val.match(/\b\w+\b/g);
        for (_j = 0, _len1 = words.length; _j < _len1; _j++) {
          w = words[_j];
          val = val.replace(new RegExp("\\b" + w + "\\b"), token(w, stack));
        }
        return val;
      } else {
        stack.pop();
        return name;
      }
    };
    include = function(name, ident) {
      var c, dir, incPath, iv, p, _j, _k, _l, _len1, _len2;
      name = name.trim();
      if (name === '' || (name == null)) {
        warn("Can't include file by empty path!");
        return '';
      }
      if ((c = name.charAt(0)) === '"') {
        if (name.charAt(0) !== name.charAt(name.length - 1)) {
          warn("Parse error: can't parse include path");
          return '';
        }
        p = name.substr(1, name.length - 2);
        iv = 2;
      } else if (c === '<') {
        if (name.charAt(name.length - 1) !== '>') {
          warn("Including system file not complete");
          return '';
        }
        p = name.substr(1, name.length - 2);
        iv = 1;
      } else {
        p = token(name);
        if (p === p) {
          warn("Cannot find macro for " + (p.white().bold()));
          return '';
        } else if (p === '') {
          warn("Can't include by empty path");
          return '';
        }
        return include(p, ident);
      }
      incPath = null;
      switch (iv) {
        case 1:
          if (p.charAt(0) === '/') {
            warn("Path between < > can't start from /");
            return '';
          }
          for (_j = 0, _len1 = systemPaths.length; _j < _len1; _j++) {
            dir = systemPaths[_j];
            if (fs.existsSync(dir + "/" + p)) {
              incPath = dir + '/' + p;
              break;
            }
          }
          if (incPath != null) {
            break;
          }
          warn("File " + (p.white().bold()) + " cannot find in system dirs. Error:");
          return '';
        case 2:
          if (p.charAt(0) === '/') {
            warn("Absolute path is not safe!");
            if (!fs.existsSync(p)) {
              warn("Include error: " + (p.white().bold()) + " not exist");
              return '';
            }
            incPath = p;
            break;
          }
          for (_k = dirOpen.length - 1; _k >= 0; _k += -1) {
            dir = dirOpen[_k];
            if (fs.existsSync(dir + "/" + p)) {
              incPath = dir + "/" + p;
              break;
            }
          }
          if (incPath != null) {
            break;
          }
          for (_l = 0, _len2 = systemPaths.length; _l < _len2; _l++) {
            dir = systemPaths[_l];
            if (fs.existsSync(dir + "/" + p)) {
              incPath = dir + '/' + p;
              break;
            }
          }
          if (incPath != null) {
            break;
          }
          warn("File " + (p.white().bold()) + " cannot find.");
          return '';
        default:
          error("O__o WTF!?");
      }
      if (incPath == null) {
        error("Include error. Can't find and not print warn and out");
        return '';
      }
      dir = path.dirname(incPath);
      if (__indexOf.call(dirOpen, dir) < 0) {
        dirOpen.push(dir);
      }
      if (gw != null) {
        subscribeChange(incPath, gn, gw);
      }
      return ident + cPreProcessor(fs.readFileSync(incPath).toString(), incPath, ident);
    };
    warn = function(message) {
      return console.warn(message.yellow(), filename.white(), ''.cyan(line));
    };
    error = function(message) {
      return console.error(message.red().bold());
    };
    while (i++ < l) {
      c = source.charAt(i);
      c2 = source.charAt(i + 1);
      if (c === '\\') {
        if (source.substr(i + 1, 2) === '\n#') {
          i += 3;
          line++;
          continue;
        } else if (source.substr(i + 1, 2) === '\r\n#') {
          i += 4;
          line++;
          continue;
        }
      }
      ba = ifactive === 0 || iftrue;
      if (!ba) {
        s = true;
      }
      if (!ecran) {
        switch (c) {
          case "'":
          case "`":
            f = c === "'" ? 0x1 : 0x20;
            if (!cl) {
              if (q === 0) {
                q = f;
              } else if (q === f) {
                q = 0;
              }
            }
            if (q === 0x1) {
              replace = false;
            } else {
              replace = true;
            }
            f = 0;
            break;
          case '/':
          case '"':
            if (c2 === c && source.charAt(i + 2) === c) {
              f = c === '/' ? 0x40 : 0x4;
              i += 2;
              if (ba) {
                buf += c + c;
              }
            } else {
              f = c === '/' ? 0x8 : 0x2;
            }
            if (!cl) {
              if (q === 0) {
                q = f;
              } else if (q === f) {
                q = 0;
              }
            }
            f = 0;
            break;
          case '#':
            if (q !== 0 && q !== 0x10) {
              break;
            }
            if (c2 === c && source.charAt(i + 2) === c) {
              f = 0x10;
              i += 2;
              if (ba) {
                buf += '##';
              }
              if (q === f) {
                f = 0;
              }
            } else if (c2 !== '@') {
              cl = true;
            } else if (!cl) {
              sd = true;
            }
            q = f;
            if (sd && q !== 0x10) {
              d = true;
              s = true;
              i++;
            }
            f = 0;
            break;
          case '\\':
            if (0 !== (q & (0x1 | 0x2 | 0x4 | 0x20 | 0x40 | 0x8))) {
              ecran = true;
            }
            break;
          default:
            os = true;
        }
      } else {
        ecran = false;
      }
      if (d) {
        if (sd) {
          sd = false;
          continue;
        }
        if (c !== '\n') {
          if (ad === -1) {
            if (an.test(c)) {
              word += c;
            } else {
              ad = directives.indexOf(word);
              if (ad === -1) {
                warn("cannot find preprocessor directive " + (word.bold()));
              }
              word = '';
            }
          } else {
            word += c;
          }
        } else {
          if (ad === -1 && word !== '') {
            ad = directives.indexOf(word);
            word = '';
          }
          if (ifactive > 0 && !iftrue && !((4 <= ad && ad <= 6))) {
            i = source.indexOf('\n', i) - 1;
            d = false;
            ad = -1;
            line++;
            continue;
          }
          switch (ad) {
            case -1:
              d = false;
              break;
            case 0:
              out += include(word, buf);
              break;
            case 1:
              dm = word.trim().match(def);
              if (dm == null) {
                warn("Define " + word + " fail");
              }
              define(dm[1], dm[2]);
              break;
            case 2:
              undef(word.trim());
              break;
            case 3:
              ifactive++;
              if (eval(word)) {
                iftrue = true;
                ifpassed = true;
              }
              break;
            case 4:
              if (ifactive === 0) {
                warn("#elif without #if");
                return "";
              }
              if (ifpassed) {
                i2 = source.lastIndexOf("\n", source.indexOf("#@endif", i));
                ad = -1;
                d = false;
                if (i2 === -1) {
                  warn("#endif not found");
                  return "";
                }
                word = '';
                buf = '';
                iftrue = false;
                nfound = source.substring(i, i2).match(n);
                line += ((nfound != null ? nfound.length : void 0) || 0) + 1;
                i = i2;
                continue;
              }
              if (iftrue) {
                iftrue = false;
              } else if (eval(word)) {
                iftrue = true;
              }
              break;
            case 5:
              if (ifactive === 0) {
                warn("#else without #if");
                return "";
              }
              if (ifpassed) {
                i2 = source.lastIndexOf("\n", source.indexOf("#@endif", i));
                ad = -1;
                d = false;
                if (i2 === -1) {
                  warn("#endif not found");
                  return "";
                }
                word = '';
                buf = '';
                iftrue = false;
                nfound = source.substring(i, i2).match(n);
                line += ((nfound != null ? nfound.length : void 0) || 0) + 1;
                i = i2;
                continue;
              }
              iftrue = !iftrue;
              break;
            case 6:
              if (ifactive === 0) {
                warn("#endif without #if");
                return "";
              }
              if (!sl.test(word)) {
                warn("#endif not empty");
              }
              ifactive--;
              ifpassed = ifactive !== 0;
              break;
            case 7:
              ifactive++;
              ifpassed = iftrue = makros.hasOwnProperty(word) && (makros[word] != null);
              break;
            case 8:
              ifactive++;
              ifpassed = iftrue = !(makros.hasOwnProperty(word) && (makros[word] != null));
              break;
            default:
              warn("What!?");
          }
          ad = -1;
          d = false;
          word = '';
          buf = '';
        }
        s = true;
      } else {
        if (ba) {
          if (isw = an.test(c)) {
            word += c;
          } else {
            buf += c;
          }
          if (isw && !an.test(c2)) {
            wr = word === '' ? '' : token(word);
            if (wr !== word) {
              if (buf.charAt(buf.length - 1) === ' ') {
                buf += wr;
              } else {
                buf += ' ' + wr;
              }
              if (c2 !== ' ') {
                buf += ' ';
              }
            } else {
              buf += word;
            }
            word = '';
          }
        }
        s = true;
      }
      if (c === '\n') {
        line++;
        c += indent;
        cl = false;
        word = '';
        if (ba) {
          out += buf;
        }
        buf = indent;
      }
      if (!s) {
        buf += c;
      } else {
        s = false;
      }
    }
    if (c === "") {
      out += buf;
    }
    return out.substr(0, out.length - 1);
  };

  optionParse = function(opts) {
    var dirs, o, sp, _j, _k, _len1, _len2, _ref;
    _ref = opts.params;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      o = _ref[_j];
      if (o.substr(0, 2) === '-I') {
        sp = o.substr(2).trim().replace(/\/$/, '');
        if (__indexOf.call(systemPaths, sp) < 0) {
          systemPaths.push(sp);
        }
      }
    }
    if (process.env.hasOwnProperty('COFFEE_INCLUDE')) {
      dirs = process.env.COFFEE_INCLUDE.split(':');
      for (_k = 0, _len2 = dirs.length; _k < _len2; _k++) {
        o = dirs[_k];
        o = o.trim().replace(/\/$/, '');
        if (__indexOf.call(systemPaths, o) < 0) {
          systemPaths.push(o);
        }
      }
    }
  };

  module.exports = function(data, name, watcher, opts) {
    var ret;
    gw = watcher || null;
    gn = name;
    optionParse(opts);
    unsubscribeChange(name);
    makros = {};
    dirOpen = [path.dirname(name)];
    ret = cPreProcessor(data, name, '');
    gw = null;
    gn = '';
    return ret;
  };

}).call(this);
