// Generated by CoffeeScript 1.7.1
(function() {
  var cPreProcessor, dirOpen, fs, gn, gw, makros, optionParse, path, startWatcher, subscribeChange, systemPaths, timers, unsubscribeChange, wait, watchers,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  makros = null;

  watchers = {};

  systemPaths = [];

  dirOpen = null;

  gw = null;

  gn = '';

  timers = {};

  wait = function(time, func) {
    return setTimeout(func, time);
  };

  startWatcher = function(path) {
    fs.exists(path, function(e) {
      if (!e) {
        console.log("\x1B[1;31mFile not exists: \x1b[1;37m " + path + "\x1B[0m\n");
        return;
      }
      fs.watch(path, function(action, pathChanged) {
        if (timers[pathChanged] != null) {
          clearTimeout(timers[pathChanged]);
        }
        timers[pathChanged] = wait(25, function() {
          var i, w, _ref;
          _ref = watchers[path];
          for (i in _ref) {
            if (!__hasProp.call(_ref, i)) continue;
            w = _ref[i];
            if (w != null) {
              if (typeof w.emit === "function") {
                w.emit('change', true);
              }
            }
          }
        });
      });
    });
  };

  subscribeChange = function(pathChangedFile, pathCoreFile, coreWatchers) {
    if (watchers[pathChangedFile] == null) {
      watchers[pathChangedFile] = {};
    }
    watchers[pathChangedFile][pathCoreFile] = coreWatchers;
    return startWatcher(pathChangedFile);
  };

  unsubscribeChange = function(pathCoreFile) {
    var collect, i;
    for (i in watchers) {
      if (!__hasProp.call(watchers, i)) continue;
      collect = watchers[i];
      if (collect.hasOwnProperty(pathCoreFile)) {
        delete collect[pathCoreFile];
      }
    }
  };

  cPreProcessor = function(source, filename, indent) {
    var ad, an, ba, buf, c, cl, d, def, define, directives, dm, f, i, ifactive, ifpassed, iftrue, include, l, line, os, out, q, qt, s, sd, sl, token, undef, word;
    if (indent == null) {
      indent = "";
    }
    directives = ['include', 'define', 'undef', 'if', 'elif', 'else', 'endif', 'ifdef', 'ifndef'];
    word = '';
    an = /\w/;
    qt = /'|"/;
    sl = /^\s*$/;
    def = /^(\w+)(?:\s+(.*))?$/;
    dm = null;
    out = '';
    buf = '';
    f = 0;
    q = 0x0;
    s = false;
    cl = false;
    d = false;
    sd = false;
    os = false;
    ba = false;
    iftrue = false;
    ifactive = 0;
    ifpassed = false;
    ad = -1;
    i = -1;
    l = source.length;
    line = 1;
    define = function(name, value) {
      if (value == null) {
        makros[name] = '';
        return;
      }
      makros[name] = value;
    };
    undef = function(name) {
      if (name !== '') {
        if (makros.hasOwnProperty(name)) {
          return makros[name] = null;
        } else {
          return console.warn("Index " + name + " haven't in makros. Undef fail in " + filename + ":" + line);
        }
      } else {
        return console.warn("Undef is empty in " + filename + ":" + line);
      }
    };
    token = function(name, stack) {
      var val, w, words, _i, _len;
      if (stack == null) {
        stack = [];
      }
      if (makros.hasOwnProperty(name) && (makros[name] != null)) {
        if (stack.length > 32) {
          console.warn("Tikeniz stak max size!!! fail in " + filename + ":" + line);
          stack.pop();
          return name;
        }
        if (stack.length > 16) {
          console.warn("Tikeniz stak warn size: " + stack.length + " fail in " + filename + ":" + line);
        }
        if (__indexOf.call(stack, name) >= 0) {
          stack.pop();
          return name;
        }
        val = makros[name];
        words = val.match(/\b\w+\b/g);
        for (_i = 0, _len = words.length; _i < _len; _i++) {
          w = words[_i];
          stack.push(w);
          val = val.replace(new RegExp("\\b" + w + "\\b"), token(w, stack));
        }
        return val;
      } else {
        stack.pop();
        return name;
      }
    };
    include = function(name, ident) {
      var c, dir, incPath, iv, p, _i, _j, _k, _len, _len1;
      name = name.trim();
      if (name === '' || (name == null)) {
        console.warn(" Can't include file by empty path! " + filename + ":" + line);
        return '';
      }
      if ((c = name.charAt(0)) === '"') {
        if (name.charAt(0) !== name.charAt(name.length - 1)) {
          console.warn("Parse error: can't parse include path in " + filename + ":" + line);
          return '';
        }
        p = name.substr(1, name.length - 2);
        iv = 2;
      } else if (c === '<') {
        if (name.charAt(name.length - 1) !== '>') {
          console.warn("Including system file not complete in " + filename + ":" + line);
          return '';
        }
        p = name.substr(1, name.length - 2);
        iv = 1;
      } else {
        p = token(name);
        if (p === p) {
          console.warn("Cannot find macro for " + p + " in " + filename + ":" + line);
          return '';
        } else if (p === '') {
          console.warn("Can't include by empty path in " + filename + ":" + line);
          return '';
        }
        return include(p, ident);
      }
      incPath = null;
      switch (iv) {
        case 1:
          if (p.charAt(0) === '/') {
            console.warn("Path between < > can't start from / in " + filename + ":" + line);
            return '';
          }
          for (_i = 0, _len = systemPaths.length; _i < _len; _i++) {
            dir = systemPaths[_i];
            if (fs.existsSync(dir + "/" + p)) {
              incPath = dir + '/' + p;
              break;
            }
          }
          if (incPath != null) {
            break;
          }
          console.warn("File " + p + " cannot find in system dirs. Error: " + filename + ":" + line);
          return '';
        case 2:
          if (p.charAt(0) === '/') {
            console.warn("Absolute path is not safe! " + filename + ":" + line);
            if (!fs.existsSync(p)) {
              console.warn("Include error: " + p + " not exist in " + filename + ":" + line);
              return '';
            }
            incPath = p;
            break;
          }
          for (_j = dirOpen.length - 1; _j >= 0; _j += -1) {
            dir = dirOpen[_j];
            if (fs.existsSync(dir + "/" + p)) {
              incPath = dir + "/" + p;
              break;
            }
          }
          if (incPath != null) {
            break;
          }
          for (_k = 0, _len1 = systemPaths.length; _k < _len1; _k++) {
            dir = systemPaths[_k];
            if (fs.existsSync(dir + "/" + p)) {
              incPath = dir + '/' + p;
              break;
            }
          }
          if (incPath != null) {
            break;
          }
          console.warn("File " + p + " cannot find. Error: " + filename + ":" + line);
          return '';
        default:
          console.error("O__o WTF!?");
      }
      if (incPath == null) {
        console.error("Include error. Can't find and not print warn and out");
        return '';
      }
      dir = path.dirname(incPath);
      if (__indexOf.call(dirOpen, dir) < 0) {
        dirOpen.push(dir);
      }
      if (gw != null) {
        subscribeChange(p, gn, gw);
      }
      return ident + cPreProcessor(fs.readFileSync(incPath).toString(), incPath, ident);
    };
    while (i++ < l) {
      c = source.charAt(i);
      if (c === '\\') {
        if (source.substr(i + 1, 2) === '\n#') {
          i += 3;
          continue;
        } else if (source.substr(i + 1, 2) === '\r\n#') {
          i += 4;
          continue;
        }
      }
      ba = ifactive === 0 || iftrue;
      if (!ba) {
        s = true;
      }
      switch (c) {
        case "'":
        case "`":
          f = c === "'" ? 0x1 : 0x20;
          if (!cl) {
            if (q === 0) {
              q = f;
            } else if (q === f) {
              q = 0;
            }
          }
          f = 0;
          break;
        case '/':
        case '"':
          if (source.charAt(i + 1) === c && source.charAt(i + 2) === c) {
            f = c === '/' ? 0x8 : 0x4;
            i += 2;
            if (ba) {
              buf += c + c;
            }
          } else {
            f = c === '/' ? 0x40 : 0x2;
          }
          if (!cl) {
            if (q === 0) {
              q = f;
            } else if (q === f) {
              q = 0;
            }
          }
          f = 0;
          break;
        case '#':
          if (q !== 0) {
            os = true;
            break;
          }
          if (source.charAt(i + 1) === c && source.charAt(i + 2) === c) {
            f = 0x10;
            i += 2;
            if (ba) {
              buf += '##';
            }
          } else if (source.charAt(i + 1) !== '@') {
            cl = true;
          } else if (!cl) {
            sd = true;
          }
          q = f;
          if (sd && q !== 0x10) {
            d = true;
            s = true;
            i++;
          }
          f = 0;
          break;
        default:
          os = true;
      }
      if (d) {
        if (sd) {
          sd = false;
          continue;
        }
        if (c !== '\n') {
          if (ad === -1) {
            if (an.test(c)) {
              word += c;
            } else {
              ad = directives.indexOf(word);
              if (ad === -1) {
                console.warn("cannot find preprocessor directive " + word + "  in " + filename + ":" + line);
              }
              word = '';
            }
          } else {
            word += c;
          }
        } else {
          if (ad === -1 && word !== '') {
            ad = directives.indexOf(word);
            word = '';
          }
          if (ifactive > 0 && !iftrue && !((4 <= ad && ad <= 6))) {
            i = source.indexOf('\n', i) - 1;
            d = false;
            ad = -1;
            continue;
          }
          switch (ad) {
            case -1:
              d = false;
              break;
            case 0:
              out += include(word, buf);
              break;
            case 1:
              dm = word.trim().match(def);
              if (dm == null) {
                console.warn("Define " + word + " fail in " + filename + ":" + line);
              }
              define(dm[1], dm[2]);
              break;
            case 2:
              undef(word.trim());
              break;
            case 3:
              ifactive++;
              if (eval(word)) {
                iftrue = true;
                ifpassed = true;
              }
              break;
            case 4:
              if (ifactive === 0) {
                console.warn("elif without #if in " + filename + ":" + line);
                return "";
              }
              if (ifpassed) {
                i = source.lastIndexOf("\n", source.indexOf("#@endif", i));
                ad = -1;
                d = false;
                word = '';
                buf = '';
                iftrue = false;
                continue;
              }
              if (iftrue) {
                iftrue = false;
              } else if (eval(word)) {
                iftrue = true;
              }
              break;
            case 5:
              if (ifactive === 0) {
                console.warn("else without #if in " + filename + ":" + line);
                return "";
              }
              if (ifpassed) {
                i = source.lastIndexOf("\n", source.indexOf("#@endif", i));
                ad = -1;
                d = false;
                word = '';
                buf = '';
                iftrue = false;
                continue;
              }
              iftrue = !iftrue;
              break;
            case 6:
              if (ifactive === 0) {
                console.warn("endif without #if in " + filename + ":" + line);
                return "";
              }
              if (!sl.test(word)) {
                console.warn("endif not empty in " + filename + ":" + line);
              }
              ifactive--;
              ifpassed = ifactive !== 0;
              break;
            case 7:
              ifactive++;
              ifpassed = iftrue = makros.hasOwnProperty(word) && (makros[word] != null);
              break;
            case 8:
              ifactive++;
              ifpassed = iftrue = !(makros.hasOwnProperty(word) && (makros[word] != null));
              break;
            default:
              console.log("What!? in " + filename + ":" + line);
          }
          ad = -1;
          d = false;
          word = '';
          buf = '';
        }
        s = true;
      } else {
        if (ba) {
          if (an.test(c)) {
            word += c;
          } else {
            if (makros.hasOwnProperty(word) && (makros[word] != null)) {
              if (buf.charAt(buf.length - 1) === ' ') {
                buf += makros[word];
              } else {
                buf += ' ' + makros[word];
              }
              if (source.charAt(i + 1) !== ' ') {
                buf += ' ';
              }
            } else {
              buf += word;
            }
            word = '';
            buf += c;
          }
        }
        s = true;
      }
      if (c === '\n') {
        line++;
        c += indent;
        cl = false;
        word = '';
        if (ba) {
          out += buf;
        }
        buf = indent;
      }
      if (!s) {
        buf += c;
      } else {
        s = false;
      }
    }
    if (c === "") {
      out += buf;
    }
    return out;
  };

  optionParse = function(opts) {
    var dirs, o, sp, _i, _j, _len, _len1, _ref;
    _ref = opts["arguments"];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      o = _ref[_i];
      if (o.substr(0, 2) === '-I') {
        sp = o.substr(2).trim().replace(/\/$/, '');
        if (__indexOf.call(systemPaths, sp) < 0) {
          systemPaths.push(sp);
        }
      }
    }
    if (process.env.hasOwnProperty('COFFEE_INCLUDE')) {
      dirs = process.env.COFFEE_INCLUDE.split(':');
      for (_j = 0, _len1 = dirs.length; _j < _len1; _j++) {
        o = dirs[_j];
        o = o.trim().replace(/\/$/, '');
        if (__indexOf.call(systemPaths, o) < 0) {
          systemPaths.push(o);
        }
      }
    }
  };

  module.exports = function(data, name, watcher, opts) {
    var ret;
    gw = watcher || null;
    gn = name;
    optionParse(opts);
    unsubscribeChange(name);
    makros = {};
    dirOpen = [path.dirname(name)];
    ret = cPreProcessor(data, name, '');
    gw = null;
    gn = '';
    return ret;
  };

}).call(this);
