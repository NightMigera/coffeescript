// Generated by CoffeeScript 1.7.1
(function() {
  var cPreProcessor, dirOpen, fs, gn, gw, makros, optionParse, path, startWatcher, style, styles, subscribeChange, systemPaths, timers, unsubscribeChange, wait, watchers, _fn, _i, _len,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  makros = null;

  watchers = {};

  systemPaths = [];

  dirOpen = null;

  gw = null;

  gn = '';

  timers = {};

  if ((typeof process !== "undefined" && process !== null) && !(/^win/.test(process.platform))) {
    styles = {
      'bold': ['\x1B[1m', '\x1B[22m'],
      'italic': ['\x1B[3m', '\x1B[23m'],
      'underline': ['\x1B[4m', '\x1B[24m'],
      'inverse': ['\x1B[7m', '\x1B[27m'],
      'strikethrough': ['\x1B[9m', '\x1B[29m'],
      'white': ['\x1B[37m', '\x1B[39m'],
      'grey': ['\x1B[90m', '\x1B[39m'],
      'black': ['\x1B[30m', '\x1B[39m'],
      'blue': ['\x1B[34m', '\x1B[39m'],
      'cyan': ['\x1B[36m', '\x1B[39m'],
      'green': ['\x1B[32m', '\x1B[39m'],
      'magenta': ['\x1B[35m', '\x1B[39m'],
      'red': ['\x1B[31m', '\x1B[39m'],
      'yellow': ['\x1B[33m', '\x1B[39m'],
      'whiteBG': ['\x1B[47m', '\x1B[49m'],
      'greyBG': ['\x1B[49;5;8m', '\x1B[49m'],
      'blackBG': ['\x1B[40m', '\x1B[49m'],
      'blueBG': ['\x1B[44m', '\x1B[49m'],
      'cyanBG': ['\x1B[46m', '\x1B[49m'],
      'greenBG': ['\x1B[42m', '\x1B[49m'],
      'magentaBG': ['\x1B[45m', '\x1B[49m'],
      'redBG': ['\x1B[41m', '\x1B[49m'],
      'yellowBG': ['\x1B[43m', '\x1B[49m']
    };
    _fn = function(style) {
      return String.prototype[style] = function(val) {
        if (val == null) {
          val = '';
        }
        return styles[style][0] + this + val + styles[style][1];
      };
    };
    for (style in styles) {
      if (!__hasProp.call(styles, style)) continue;
      _fn(style);
    }
  } else {
    styles = ['bold', 'italic', 'underline', 'inverse', 'strikethrough', 'white', 'grey', 'black', 'blue', 'cyan', 'green', 'magenta', 'red', 'yellow', 'whiteBG', 'greyBG', 'blackBG', 'blueBG', 'cyanBG', 'greenBG', 'magentaBG', 'redBG', 'yellowBG'];
    for (_i = 0, _len = styles.length; _i < _len; _i++) {
      style = styles[_i];
      String.prototype[style] = function(val) {
        if (val == null) {
          val = '';
        }
        return this + val;
      };
    }
  }

  wait = function(time, func) {
    return setTimeout(func, time);
  };

  startWatcher = function(path) {
    fs.exists(path, function(e) {
      if (!e) {
        console.log(("" + ('File not exists:'.red()) + " " + (path.white()) + "\n").bold());
        return;
      }
      fs.watch(path, function(action, pathChanged) {
        if (timers[pathChanged] != null) {
          clearTimeout(timers[pathChanged]);
        }
        timers[pathChanged] = wait(25, function() {
          var i, w, _ref;
          _ref = watchers[path];
          for (i in _ref) {
            if (!__hasProp.call(_ref, i)) continue;
            w = _ref[i];
            if (w != null) {
              if (typeof w.emit === "function") {
                w.emit('change', true);
              }
            }
          }
        });
      });
    });
  };

  subscribeChange = function(pathChangedFile, pathCoreFile, coreWatchers) {
    if (watchers[pathChangedFile] == null) {
      watchers[pathChangedFile] = {};
    }
    watchers[pathChangedFile][pathCoreFile] = coreWatchers;
    return startWatcher(pathChangedFile);
  };

  unsubscribeChange = function(pathCoreFile) {
    var collect, i;
    for (i in watchers) {
      if (!__hasProp.call(watchers, i)) continue;
      collect = watchers[i];
      if (collect.hasOwnProperty(pathCoreFile)) {
        delete collect[pathCoreFile];
      }
    }
  };

  cPreProcessor = function(source, filename, indent) {
    var ad, an, ba, buf, c, cl, d, def, define, directives, dm, f, i, ifactive, ifpassed, iftrue, include, l, line, os, out, q, qt, s, sd, sl, token, undef, word;
    if (indent == null) {
      indent = "";
    }
    directives = ['include', 'define', 'undef', 'if', 'elif', 'else', 'endif', 'ifdef', 'ifndef'];
    word = '';
    an = /\w/;
    qt = /'|"/;
    sl = /^\s*$/;
    def = /^(\w+)(?:\s+(.*))?$/;
    dm = null;
    out = '';
    buf = '';
    f = 0;
    q = 0x0;
    source += '\n';
    s = false;
    cl = false;
    d = false;
    sd = false;
    os = false;
    ba = false;
    iftrue = false;
    ifactive = 0;
    ifpassed = false;
    ad = -1;
    i = -1;
    l = source.length;
    line = 1;
    define = function(name, value) {
      if (value == null) {
        makros[name] = '';
        return;
      }
      makros[name] = value;
    };
    undef = function(name) {
      if (name !== '') {
        if (makros.hasOwnProperty(name)) {
          return makros[name] = null;
        } else {
          return console.warn(("Index " + (name.blue()) + " haven't in makros. Undef fail in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
        }
      } else {
        return console.warn(("Undef is empty in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
      }
    };
    token = function(name, stack) {
      var val, w, words, _j, _len1;
      if (stack == null) {
        stack = [];
      }
      if (makros.hasOwnProperty(name) && (makros[name] != null)) {
        if (stack.length > 32) {
          console.warn(("Tikeniz stak max size!!! fail in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
          stack.pop();
          return name;
        }
        if (stack.length > 16) {
          console.warn(("Tikeniz stak warn size: " + stack.length + " fail in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
        }
        if (__indexOf.call(stack, name) >= 0) {
          stack.pop();
          return name;
        }
        val = makros[name];
        words = val.match(/\b\w+\b/g);
        for (_j = 0, _len1 = words.length; _j < _len1; _j++) {
          w = words[_j];
          stack.push(w);
          val = val.replace(new RegExp("\\b" + w + "\\b"), token(w, stack));
        }
        return val;
      } else {
        stack.pop();
        return name;
      }
    };
    include = function(name, ident) {
      var c, dir, incPath, iv, p, _j, _k, _l, _len1, _len2;
      name = name.trim();
      if (name === '' || (name == null)) {
        console.warn(("Can't include file by empty path! " + (filename.white()) + ":" + (''.cyan(line))).yellow());
        return '';
      }
      if ((c = name.charAt(0)) === '"') {
        if (name.charAt(0) !== name.charAt(name.length - 1)) {
          console.warn(("Parse error: can't parse include path in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
          return '';
        }
        p = name.substr(1, name.length - 2);
        iv = 2;
      } else if (c === '<') {
        if (name.charAt(name.length - 1) !== '>') {
          console.warn(("Including system file not complete in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
          return '';
        }
        p = name.substr(1, name.length - 2);
        iv = 1;
      } else {
        p = token(name);
        if (p === p) {
          console.warn(("Cannot find macro for " + (p.white().bold()) + " in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
          return '';
        } else if (p === '') {
          console.warn(("Can't include by empty path in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
          return '';
        }
        return include(p, ident);
      }
      incPath = null;
      switch (iv) {
        case 1:
          if (p.charAt(0) === '/') {
            console.warn(("Path between < > can't start from / in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
            return '';
          }
          for (_j = 0, _len1 = systemPaths.length; _j < _len1; _j++) {
            dir = systemPaths[_j];
            if (fs.existsSync(dir + "/" + p)) {
              incPath = dir + '/' + p;
              break;
            }
          }
          if (incPath != null) {
            break;
          }
          console.warn(("File " + (p.white().bold()) + " cannot find in system dirs. Error: " + (filename.white()) + ":" + (''.cyan(line))).yellow());
          return '';
        case 2:
          if (p.charAt(0) === '/') {
            console.warn(("Absolute path is not safe! " + (filename.white()) + ":" + (''.cyan(line))).yellow());
            if (!fs.existsSync(p)) {
              console.warn(("Include error: " + (p.white().bold()) + " not exist in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
              return '';
            }
            incPath = p;
            break;
          }
          for (_k = dirOpen.length - 1; _k >= 0; _k += -1) {
            dir = dirOpen[_k];
            if (fs.existsSync(dir + "/" + p)) {
              incPath = dir + "/" + p;
              break;
            }
          }
          if (incPath != null) {
            break;
          }
          for (_l = 0, _len2 = systemPaths.length; _l < _len2; _l++) {
            dir = systemPaths[_l];
            if (fs.existsSync(dir + "/" + p)) {
              incPath = dir + '/' + p;
              break;
            }
          }
          if (incPath != null) {
            break;
          }
          console.warn(("File " + (p.white().bold()) + " cannot find. Error: " + (filename.white()) + ":" + (''.cyan(line))).yellow());
          return '';
        default:
          console.error("O__o WTF!?".red().bold());
      }
      if (incPath == null) {
        console.error("Include error. Can't find and not print warn and out".red().bold());
        return '';
      }
      dir = path.dirname(incPath);
      if (__indexOf.call(dirOpen, dir) < 0) {
        dirOpen.push(dir);
      }
      if (gw != null) {
        subscribeChange(incPath, gn, gw);
      }
      return ident + cPreProcessor(fs.readFileSync(incPath).toString(), incPath, ident);
    };
    while (i++ < l) {
      c = source.charAt(i);
      if (c === '\\') {
        if (source.substr(i + 1, 2) === '\n#') {
          i += 3;
          continue;
        } else if (source.substr(i + 1, 2) === '\r\n#') {
          i += 4;
          continue;
        }
      }
      ba = ifactive === 0 || iftrue;
      if (!ba) {
        s = true;
      }
      switch (c) {
        case "'":
        case "`":
          f = c === "'" ? 0x1 : 0x20;
          if (!cl) {
            if (q === 0) {
              q = f;
            } else if (q === f) {
              q = 0;
            }
          }
          f = 0;
          break;
        case '/':
        case '"':
          if (source.charAt(i + 1) === c && source.charAt(i + 2) === c) {
            f = c === '/' ? 0x8 : 0x4;
            i += 2;
            if (ba) {
              buf += c + c;
            }
          } else {
            f = c === '/' ? 0x40 : 0x2;
          }
          if (!cl) {
            if (q === 0) {
              q = f;
            } else if (q === f) {
              q = 0;
            }
          }
          f = 0;
          break;
        case '#':
          if (q !== 0) {
            os = true;
            break;
          }
          if (source.charAt(i + 1) === c && source.charAt(i + 2) === c) {
            f = 0x10;
            i += 2;
            if (ba) {
              buf += '##';
            }
          } else if (source.charAt(i + 1) !== '@') {
            cl = true;
          } else if (!cl) {
            sd = true;
          }
          q = f;
          if (sd && q !== 0x10) {
            d = true;
            s = true;
            i++;
          }
          f = 0;
          break;
        default:
          os = true;
      }
      if (d) {
        if (sd) {
          sd = false;
          continue;
        }
        if (c !== '\n') {
          if (ad === -1) {
            if (an.test(c)) {
              word += c;
            } else {
              ad = directives.indexOf(word);
              if (ad === -1) {
                console.warn(("cannot find preprocessor directive " + (word.bold()) + "  in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
              }
              word = '';
            }
          } else {
            word += c;
          }
        } else {
          if (ad === -1 && word !== '') {
            ad = directives.indexOf(word);
            word = '';
          }
          if (ifactive > 0 && !iftrue && !((4 <= ad && ad <= 6))) {
            i = source.indexOf('\n', i) - 1;
            d = false;
            ad = -1;
            continue;
          }
          switch (ad) {
            case -1:
              d = false;
              break;
            case 0:
              out += include(word, buf);
              break;
            case 1:
              dm = word.trim().match(def);
              if (dm == null) {
                console.warn(("Define " + word + " fail in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
              }
              define(dm[1], dm[2]);
              break;
            case 2:
              undef(word.trim());
              break;
            case 3:
              ifactive++;
              if (eval(word)) {
                iftrue = true;
                ifpassed = true;
              }
              break;
            case 4:
              if (ifactive === 0) {
                console.warn(("elif without #if in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
                return "";
              }
              if (ifpassed) {
                i = source.lastIndexOf("\n", source.indexOf("#@endif", i));
                ad = -1;
                d = false;
                word = '';
                buf = '';
                iftrue = false;
                continue;
              }
              if (iftrue) {
                iftrue = false;
              } else if (eval(word)) {
                iftrue = true;
              }
              break;
            case 5:
              if (ifactive === 0) {
                console.warn(("else without #if in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
                return "";
              }
              if (ifpassed) {
                i = source.lastIndexOf("\n", source.indexOf("#@endif", i));
                ad = -1;
                d = false;
                word = '';
                buf = '';
                iftrue = false;
                continue;
              }
              iftrue = !iftrue;
              break;
            case 6:
              if (ifactive === 0) {
                console.warn(("endif without #if in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
                return "";
              }
              if (!sl.test(word)) {
                console.warn(("endif not empty in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
              }
              ifactive--;
              ifpassed = ifactive !== 0;
              break;
            case 7:
              ifactive++;
              ifpassed = iftrue = makros.hasOwnProperty(word) && (makros[word] != null);
              break;
            case 8:
              ifactive++;
              ifpassed = iftrue = !(makros.hasOwnProperty(word) && (makros[word] != null));
              break;
            default:
              console.log(("What!? in " + (filename.white()) + ":" + (''.cyan(line))).yellow());
          }
          ad = -1;
          d = false;
          word = '';
          buf = '';
        }
        s = true;
      } else {
        if (ba) {
          if (an.test(c)) {
            word += c;
          } else {
            if (makros.hasOwnProperty(word) && (makros[word] != null)) {
              if (buf.charAt(buf.length - 1) === ' ') {
                buf += makros[word];
              } else {
                buf += ' ' + makros[word];
              }
              if (source.charAt(i + 1) !== ' ') {
                buf += ' ';
              }
            } else {
              buf += word;
            }
            word = '';
            buf += c;
          }
        }
        s = true;
      }
      if (c === '\n') {
        line++;
        c += indent;
        cl = false;
        word = '';
        if (ba) {
          out += buf;
        }
        buf = indent;
      }
      if (!s) {
        buf += c;
      } else {
        s = false;
      }
    }
    if (c === "") {
      out += buf;
    }
    return out.substr(0, out.length - 1);
  };

  optionParse = function(opts) {
    var dirs, o, sp, _j, _k, _len1, _len2, _ref;
    _ref = opts.params;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      o = _ref[_j];
      if (o.substr(0, 2) === '-I') {
        sp = o.substr(2).trim().replace(/\/$/, '');
        if (__indexOf.call(systemPaths, sp) < 0) {
          systemPaths.push(sp);
        }
      }
    }
    if (process.env.hasOwnProperty('COFFEE_INCLUDE')) {
      dirs = process.env.COFFEE_INCLUDE.split(':');
      for (_k = 0, _len2 = dirs.length; _k < _len2; _k++) {
        o = dirs[_k];
        o = o.trim().replace(/\/$/, '');
        if (__indexOf.call(systemPaths, o) < 0) {
          systemPaths.push(o);
        }
      }
    }
  };

  module.exports = function(data, name, watcher, opts) {
    var ret;
    gw = watcher || null;
    gn = name;
    optionParse(opts);
    unsubscribeChange(name);
    makros = {};
    dirOpen = [path.dirname(name)];
    ret = cPreProcessor(data, name, '');
    gw = null;
    gn = '';
    return ret;
  };

}).call(this);
