// Generated by CoffeeScript 1.7.1
(function() {
  var cPreProcessor, fs, gn, gw, makros, path, rewatch, startWatcher, watchers;

  fs = require('fs');

  path = require('path');

  makros = {};

  watchers = {};

  gw = null;

  gn = '';

  startWatcher = function(watcher, path) {
    var fileWatcher;
    return fileWatcher = fs.watch(path).on('change', function() {
      watcher.emit('change', true);
      if (fileWatcher != null) {
        fileWatcher.close();
      }
      rewatch(watcher, path);
    });
  };

  rewatch = function(watcher, path) {
    return startWatcher(watcher, path);
  };

  cPreProcessor = function(source, filename, indent) {
    var ad, an, ba, buf, c, cl, d, def, define, directives, dm, f, i, ifactive, ifpassed, iftrue, l, line, os, out, p, q, qt, s, sd, sl, undef, word;
    if (indent == null) {
      indent = "";
    }
    directives = ['include', 'define', 'undef', 'if', 'elif', 'else', 'endif', 'ifdef', 'ifndef'];
    word = '';
    an = /\w/;
    qt = /'|"/;
    sl = /^\s*$/;
    def = /^(\w+)(?:\s+(.*))?$/;
    dm = null;
    out = '';
    buf = '';
    f = 0;
    q = 0x0;
    s = false;
    cl = false;
    d = false;
    sd = false;
    os = false;
    ba = false;
    iftrue = false;
    ifactive = 0;
    ifpassed = false;
    ad = -1;
    i = -1;
    l = source.length;
    line = 0;
    define = function(name, value) {
      if (value != null) {
        makros[name] = value;
      } else {
        undef(name);
      }
    };
    undef = function(name) {
      if (name !== '') {
        if (makros.hasOwnProperty(name)) {
          return makros[name] = null;
        } else {
          return console.warn("Index " + name + " haven't in makros. Undef fail in " + filename + ":" + line);
        }
      } else {
        return console.error("Undef is empty in " + filename + ":" + line);
      }
    };
    while (i++ < l) {
      c = source.charAt(i);
      if (c === '\\') {
        if (source.substr(i + 1, 2) === '\n#') {
          i += 3;
          continue;
        } else if (source.substr(i + 1, 2) === '\r\n#') {
          i += 4;
          continue;
        }
      }
      ba = ifactive === 0 || iftrue;
      if (!ba) {
        s = true;
      }
      switch (c) {
        case "'":
        case "`":
          f = c === "'" ? 0x1 : 0x20;
          if (!cl) {
            if (q === 0) {
              q = f;
            } else if (q === f) {
              q = 0;
            }
          }
          f = 0;
          break;
        case '/':
        case '"':
          if (source.charAt(i + 1) === c && source.charAt(i + 2) === c) {
            f = c === '/' ? 0x8 : 0x4;
            i += 2;
            if (ba) {
              buf += c + c;
            }
          } else {
            f = c === '/' ? 0x40 : 0x2;
          }
          if (!cl) {
            if (q === 0) {
              q = f;
            } else if (q === f) {
              q = 0;
            }
          }
          f = 0;
          break;
        case '#':
          if (q !== 0) {
            os = true;
            break;
          }
          if (source.charAt(i + 1) === c && source.charAt(i + 2) === c) {
            f = 0x10;
            i += 2;
            if (ba) {
              buf += '##';
            }
          } else if (source.charAt(i + 1) !== '@') {
            cl = true;
          } else if (!cl) {
            sd = true;
          }
          q = f;
          if (sd && q !== 0x10) {
            d = true;
            s = true;
            i++;
          }
          f = 0;
          break;
        default:
          os = true;
      }
      if (d) {
        if (sd) {
          sd = false;
          continue;
        }
        if (c !== '\n') {
          if (ad === -1) {
            if (an.test(c)) {
              word += c;
            } else {
              ad = directives.indexOf(word);
              if (ad === -1) {
                console.warn("cannot find preprocessor directive " + word + "  in " + filename + ":" + line);
              }
              word = '';
            }
          } else {
            word += c;
          }
        } else {
          if (ad === -1 && word !== '') {
            ad = directives.indexOf(word);
            word = '';
          }
          if (ifactive > 0 && !iftrue && !((4 <= ad && ad <= 6))) {
            i = source.indexOf('\n', i) - 1;
            d = false;
            ad = -1;
            continue;
          }
          switch (ad) {
            case -1:
              d = false;
              break;
            case 0:
              word = word.trim();
              if (qt.test(word.charAt(0))) {
                if (word.charAt(0) !== word.charAt(word.length - 1)) {
                  console.error("Parse error: can't parse include path in " + filename + ":" + line);
                  return '';
                }
                p = word.substr(1, word.length - 2);
              } else {
                p = word + '.coffee';
              }
              if (p.charAt(0) !== '/') {
                p = path.dirname(filename) + '/' + p;
              }
              if (!fs.existsSync(p)) {
                console.error("include error: " + p + " not exist in " + filename + ":" + line);
                return '';
              }
              if (!sl.test(buf)) {
                console.error("before include exist character in " + filename + ":" + line);
                return '';
              }
              out += buf + cPreProcessor(fs.readFileSync(p).toString(), p, buf);
              if (gw != null) {
                watchers[gn].push(startWatcher(gw, p));
              }
              break;
            case 1:
              dm = word.trim().match(def);
              if (dm == null) {
                console.error("Define " + word + " fail in " + filename + ":" + line);
              }
              define(dm[1], dm[2]);
              break;
            case 2:
              undef(word.trim());
              break;
            case 3:
              ifactive++;
              if (eval(word)) {
                iftrue = true;
                ifpassed = true;
              }
              break;
            case 4:
              if (ifactive === 0) {
                console.error("elif without #if in " + filename + ":" + line);
                return "";
              }
              if (ifpassed) {
                i = source.lastIndexOf("\n", source.indexOf("#@endif", i));
                ad = -1;
                d = false;
                word = '';
                buf = '';
                iftrue = false;
                continue;
              }
              if (iftrue) {
                iftrue = false;
              } else if (eval(word)) {
                iftrue = true;
              }
              break;
            case 5:
              if (ifactive === 0) {
                console.error("else without #if in " + filename + ":" + line);
                return "";
              }
              if (ifpassed) {
                i = source.lastIndexOf("\n", source.indexOf("#@endif", i));
                ad = -1;
                d = false;
                word = '';
                buf = '';
                iftrue = false;
                continue;
              }
              iftrue = !iftrue;
              break;
            case 6:
              if (ifactive === 0) {
                console.error("endif without #if in " + filename + ":" + line);
                return "";
              }
              if (!sl.test(word)) {
                console.warn("endif not empty in " + filename + ":" + line);
              }
              ifactive--;
              ifpassed = ifactive !== 0;
              break;
            case 7:
              ifactive++;
              ifpassed = iftrue = makros.hasOwnProperty(word) && (makros[word] != null);
              break;
            case 8:
              ifactive++;
              ifpassed = iftrue = !(makros.hasOwnProperty(word) && (makros[word] != null));
              break;
            default:
              console.log("What!? in " + filename + ":" + line);
          }
          ad = -1;
          d = false;
          word = '';
          buf = '';
        }
        s = true;
      } else {
        if (ba) {
          if (an.test(c)) {
            word += c;
          } else {
            if (makros.hasOwnProperty(word) && (makros[word] != null)) {
              if (buf.charAt(buf.length - 1) === ' ') {
                buf += makros[word];
              } else {
                buf += ' ' + makros[word];
              }
              if (source.charAt(i + 1) !== ' ') {
                buf += ' ';
              }
            } else {
              buf += word;
            }
            word = '';
            buf += c;
          }
        }
        s = true;
      }
      if (c === '\n') {
        line++;
        c += indent;
        cl = false;
        word = '';
        if (ba) {
          out += buf;
        }
        buf = indent;
      }
      if (!s) {
        buf += c;
      } else {
        s = false;
      }
    }
    if (c === "") {
      out += buf;
    }
    return out;
  };

  module.exports = function(data, name, watcher) {
    var ret, w, _i, _len, _ref;
    if (watcher != null) {
      if (watchers[name]) {
        _ref = watchers[name];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          w = _ref[_i];
          w.close();
        }
      }
      watchers[name] = [];
    }
    gw = watcher || null;
    gn = name;
    ret = cPreProcessor(data, name, '');
    gw = null;
    gn = '';
    return ret;
  };

}).call(this);
